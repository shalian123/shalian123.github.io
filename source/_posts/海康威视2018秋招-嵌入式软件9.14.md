---
title: 海康威视2018秋招-嵌入式软件9.14
date: 2017-09-17 19:00:59
tags: [嵌入式,笔试]
categories: 笔试面试

---

**1.同步通信和异步通信的区别：**

同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。  

异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。

同步是阻塞模式，异步是非阻塞模式。

其中SPI 、IIC为同步通信  UART为异步通信。（SPI和UART是全双工，IIC是半双工，全双工指能同时接收和发送）

同步通信与异步通信区别：

   1.同步通信要求接收端时钟频率和发送端时钟频率一致，发送端发送连续的比特流；异步通信时不要求接收端时钟和发送端时钟同步，发送端发送完一个字节后，可经过任意长的时间间隔再发送下一个字节。

    2.同步通信效率高；异步通信效率较低。

    3.同步通信较复杂，双方时钟的允许误差较小；异步通信简单，双方时钟可允许一定误差。

    4.同步通信可用于点对多点；异步通信只适用于点对点。

    

**2.嵌入式ARM架构的嵌入式处理器的特点：**

  寻址方式简单，采用固定长度的指令格式

  具有大量的寄存器，指令执行速度快

  绝大多数操作都在寄存器中执行，通过LOAD/STORE的体系结构在内存和寄存器之间传递数据

  **不同时支**持大端小端数据格式。（采用大小模式对数据进行存放的主要区别在于在存放的字节顺序，大端方式将高位存放低地址，小端方式将高位存放高地址）

  补充：编写一段程序判断系统中的CPU 是大端 还是小端 模式？

  解答：

```

程序1：

int checkEnd()

{

int i=0x12345678;

char *c=(char *)&i; 

return(*c==0x12)

}

返回值：大端返回1，小段返回0

程序2：

int checkEnd()

{

union

{

long a;

char b

}u; 

u.a = 1;

if (u.b == 1) return 0;

else return 1;

}

返回值：大端返回1，小段返回0

```

补：intel芯片是小端(修改分区表时要注意)，单片机一般为大端



**3.多播**

多播是一点对多点的通信。

如今网络的通信方式主要有以下几种：

单播(unicast：point to point)，点到点的通信方式；

多播(multicast：point tO multipoint)，点到多点的通信方式；

汇播(concast：multipoint to point)，多点到一点的通信方式；

群播(multipoint tO multipoint)，多点到多点的通信方式，多播的一种推广；

广播(broadcast：point to all point)，点到所有节点的通信方式。

**IP多播（也称多址广播或组播）技术**，是一种允许一台或多台主机（多播源）发送单一数据包到多台主机（一次的，同时的）的TCP/IP网络技术。多播作为一点对多点的通信，是节省网络带宽的有效方法之一。

**广播和多播仅应用于UDP**，它们对需将报文同时传往多个接收者的应用来说十分重要。TCP是一个面向连接的协议，它意味着分别运行于两主机（由IP地址确定）内的两进程（由端口号确定）间存在一条连接。

**第一组八位数的头四位用1110表示**， 这代表该地址是一个多播地址， 其余28位比特标识具体的多播 地 址 。 因 此 ， 多 播 地 址 的 范 围** 从 224.0.0.0到239.255.255.255**。 其中， 后28比特的地址字段中不再有结构层次， 也不标出组的来源， 不会象 A、B、C类地址那样包含一个网络地址。多播地址的使用分配现在由互联 网 地 址 指 派 机 构 （IANA） 控 制[1]  。

补充：ip地址总共分为5类，A、B、C、D、E

A：**0-127**，其中0代表任何地址，127为回环测试地址，因此，A类ip地址的实际范围是1-126.

默认子网掩码为255.0.0.0，**实际范围是1.0.0.0--126.0.0.0**



B：**128-191**，其中128.0.0.0和191.255.0.0为保留ip

实际范围是**128.1.0.0--191.254.0.0**



C类ip地址

C：**192-223**，其中192.0.0.0和223.255.255.0为保留ip

实际范围是**192.1.0.0--223.255.254.0**



D类ip地址

**224.0.0.0到239.255.255.255**用于多点广播 



E类ip地址

**240.0.0.0到255.255.255.254**

255.255.255.255用于广播地址



**4.如何对某一位置0或者置1？**



写成宏，方便移植

```

#define setbit(x,y) x|=(1<<y) //将X的第Y位置1

#define clrbit(x,y) x&=~(1<<y) //将X的第Y位清0置位操作

```

**5.linux系统下，.a是静态链接库文件；.so是动态链接库文件；.ko 是内核模块文件，是内核加载的某个模块，一般是驱动程序。**



**6**.请写出int变量x中**第p比特位到第n比特位取反**，其他比特不变的宏定义（0<=p<=n<=31）。

```

#include <stdio.h>

#include <math.h>

//第p比特位到第n比特位取反

void intvert(int x, int p, int n)

{

	int bin_c[32], tmp_c[32];

	for (int i = 0; i < 32; i++)//将十进制转换成二进制

	{

		bin_c[i] = x % 2;

		x = x / 2;

	}

	printf("取反前二进制：\n");

	for (int i = 31; i >= 0; i--)

	{

		printf("%d", bin_c[i]);

	}

	//p = 32 - p;//初始为逆向存储，所以定位到首元素开始计算位置

 /******************************************/   

	p = p - 1;//从左往右依次从高位到低位

	while (n-p){

		//对从p开始的二进制取反

		bin_c[p] ^= 1;

		p++;

	}

 /******************************************/   

	printf("\n取反后二进制：\n");

	for (int i = 31; i >= 0; i--)

	{

		printf("%d", bin_c[i]);

	}



	printf("\n取反后十进制：\n");

	long int sum=0;

	for (int i = 31; i >= 0; i--)

	{

		if (bin_c [i]== 1){

			sum += pow(2.0, i);//2的i次方

		}

	}

	printf("%ld \n", sum);

}

int main()

{

	intvert(6535, 2, 5);

	return 0;

}

```

效果如图：

![从第2位到第5位取反](http://ols4zt49w.bkt.clouddn.com/1505701077%281%29.png)



写一函数，**将整型X的第p位开始的n个位**（二进制位）取反

```

/******************************************/将上面的星号部分改成如下

    p = p - 1;//从左往右依次从高位到低位

	while (n){

		//对从p开始的二进制取反

		bin_c[p] ^= 1;

		--n;

		p++;

	}

/******************************************/

```

效果如图：

![从第2位开始的5位取反](http://ols4zt49w.bkt.clouddn.com/1505702154%281%29.png)

**按位异或 “^”**

按位异或运算通常用来将某变量中的某些位取反，且保留其他位不变（如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。）



**7.预处理**

预处理有三种：**宏定义**、**条件编译**和**头文件**

**#ifndef..#define...#endif的作用**

**#ifndef**

它是if not define 的简写，是宏定义的一种，实际上确切的说，这应该是预处理功能三种（宏定义、文件包含、条件编译）中的一种----条件编译。

　　在c语言中，对同一个变量或者函数进行多次声明是不会报错的。所以如果h文件里只是进行了声明工作，即使不使用# ifndef宏定义，多个c文件包含同一个h文件也不会报错。

　　但是在c++语言中，#ifdef的作用域只是在单个文件中。所以如果h文件里定义了全局变量，即使采用#ifdef宏定义，多个c文件包含同一个h文件还是会出现全局变量重定义的错误。

**使用#ifndef可以避免下面这种错误：如果在h文件中定义了全局变量，一个c文件包含同一个h文件多次，如果不加#ifndef宏定义，会出现变量重复定义的错误；如果加了#ifndef，则不会出现这种错误。**



**8.左移<<，右移>>，按位与&，按位或|**

```

a << b

的值是：将a各二进位全部左移b位后得到的值。左移时，高位丢弃，低位补0。a 的值不因运算而改变。

实际上，左移1位，就等于是乘以2，左移n位，就等于是乘以2的n次方。而左移操作比乘法操作快得多。

```

```

a >> b

的值是：将a各二进位全部右移b位后得到的值。右移时，移出最右边的位就被丢弃。 a 的值不因运算而改变。

对于有符号数，如long,int,short,char类型变量，在右移时，符号位（即最高位）将一起移动，并且大多数C/C++编译器规定，如果原符号位为1，则右移时高位就补充1，原符号位为0，则右移时高位就补充0。

实际上，右移n位，就相当于左操作数除以2的n次方，并且将结果往小里取整。

-25 >> 4 = -2

-2 >> 4 = -1

18 >> 4 = 1

```

```

按位与 “&”

按位与运算通常用来将某变量中的某些位清0且同时保留其他位不变。

也可以用来获取某变量中的某一位。

例如，如果需要将int型变量n的低8位全置成0，而其余位不变，则可以执行：

n = n & 0xffffff00;

也可以写成：

n &= 0xffffff00;

如果n是short类型的，则只需执行：

n &= 0xff00;

如何判断一个int型变量n的第7位（从右往左，从0开始数）是否是1 ?

只需看表达式 “n & 0x80”的值是否等于0x80即可。

0x80: 1000 0000

```

```

按位或 “|”

按位或运算通常用来将某变量中的某些位置1且保留其他位不变。

例如，如果需要将int型变量n的低8位全置成1，而其余位不变，则可以执行：

n |= 0xff;

0xff: 1111 1111



```

**题目：在linux 32位系统下，请问调用test_cac(1,15)的结果是？

void test_cac(int high, int low)

{

	int val = high << 16 + low >> 16;

	printf("0x%x\n", val);

}**

分析：**在linux 32位系统下，int型也是占4个字节**，而**且’+‘的优先级比 ’<<‘ 和 ’>>‘ 的优先级高**，同时优先级相同的<<和>>根据相关性按照**从左往右算**。

即1<<16+15>>15

  1<<31>>15

 先算左移1<<31:    

 0000 0000 0000 0000 0000 0000 0000 0001 

 1000 0000 0000 0000 0000 0000 0000 0000



 再算右移 >>15，在右移时，符号位（即最高位）将一起移动，如果原符号位为1，则右移时高位就补充1，原符号位为0，则右移时高位就补充0。

 1111 1111 1111 1111 1000 0000 0000 0000-------------即0xffff8000